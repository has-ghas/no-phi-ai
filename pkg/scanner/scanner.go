package scanner

import (
	"context"
	"sync"
	"time"

	git "github.com/go-git/go-git/v5"
	"github.com/google/uuid"
	"github.com/pkg/errors"
	"github.com/rs/zerolog"

	"github.com/has-ghas/no-phi-ai/pkg/cfg"
	nogit "github.com/has-ghas/no-phi-ai/pkg/client/no-git"
	"github.com/has-ghas/no-phi-ai/pkg/scanner/rrr"
	"github.com/has-ghas/no-phi-ai/pkg/scanner/tracker"
)

// Scanner struct uses private fields to store scanner state and provides methods
// for running a scan of a git repository for PHI/PII data, recursively scanning
// the contents of files committed to each repository.
type Scanner struct {
	ID string `json:"id"`

	TrackerRequests *tracker.KeyTracker

	chan_requests     chan rrr.Request
	chan_errors       chan error
	ctx               context.Context
	git_config        *cfg.GitConfig
	git_manager       *nogit.GitManager
	logger            *zerolog.Logger
	result_io         rrr.ResultRecordIO
	scan_mutex        *sync.RWMutex
	scan_repositories map[string]*ScanRepository
}

// NewScanner() function initializes a new Scanner object.
func NewScanner(
	ctx context.Context,
	git_config *cfg.GitConfig,
	result_io rrr.ResultRecordIO,
) (*Scanner, error) {
	// ensure the context is not nil
	if ctx == nil {
		ctx = context.Background()
	}

	// create a logger from the context
	logger := zerolog.Ctx(ctx)

	// create a tracker.KeyTracker for tracking (responses to) requests
	tracker_requests, t_err := tracker.NewKeyTracker(tracker.ScanObjectTypeRequestResponse, logger)
	if t_err != nil {
		return nil, errors.Wrap(t_err, ErrMsgScannerCreate)
	}

	return &Scanner{
		ID:                uuid.NewString(),
		TrackerRequests:   tracker_requests,
		chan_requests:     make(chan rrr.Request),
		chan_errors:       make(chan error),
		ctx:               ctx,
		git_config:        git_config,
		git_manager:       nogit.NewGitManager(git_config, ctx),
		logger:            logger,
		result_io:         result_io,
		scan_mutex:        &sync.RWMutex{},
		scan_repositories: make(map[string]*ScanRepository),
	}, nil
}

// Scan() method uses channels and goroutines to coordinate the scanning of
// a git repository for PHI/PII data.
func (s *Scanner) Scan(
	chan_errors_send chan error,
	chan_request_send chan<- rrr.Request,
	chan_response_receive <-chan rrr.Response,
) {
	s.logger.Debug().Msg("started Scanner run")
	defer s.logger.Debug().Msg("finished Scanner run")

	repo := s.git_config.Scan.Repositories[0]
	// use s.git_manager to clone the repository
	repository, repository_err := s.git_manager.CloneRepo(repo)
	if repository_err != nil {
		s.chan_errors <- errors.Wrap(repository_err, ErrMsgCloneRepository)
		return
	}

	// create channels for coordinating between goroutines
	chan_scan_done := make(chan struct{})
	chan_quit := make(chan struct{})

	// track the progress of the scan
	go s.trackScanProgress(repo, chan_scan_done, chan_quit)
	// listen for errors generated by the scan
	go s.processErrors(chan_quit, s.chan_errors, chan_errors_send)
	// process requests generated by the scan
	go s.processRequests(
		chan_quit,
		s.chan_requests,
		chan_request_send,
		s.chan_errors,
	)
	// process responses for requests
	go s.processResponses(
		chan_quit,
		chan_response_receive,
		s.chan_errors,
	)
	// scan the repository
	go s.scanRepository(repo, repository, s.chan_errors, chan_scan_done)

	// listen for quit signal
	// TODO : replace with `go s.processResults()`
	<-chan_quit
}

// addScanRepository() method adds a new ScanRepository to the Scanner's map of
// scanned repositories.
func (s *Scanner) addScanRepository(repo *ScanRepository) error {
	// ensure the repository is not nil
	if repo == nil {
		return errors.Wrap(ErrScannerAddScanRepositoryNil, ErrMsgAddScanRepository)
	}
	if repo.ID == "" {
		return errors.Wrap(ErrScannerAddScanRepositoryEmptyID, ErrMsgAddScanRepository)
	}
	s.logger.Debug().Msgf("adding scan repository for %s", repo.ID)

	// lock the scan mutex to prevent concurrent access to the map
	s.scan_mutex.Lock()
	// unlock the scan mutex when the method returns
	defer s.scan_mutex.Unlock()
	s.scan_repositories[repo.ID] = repo

	return nil
}

// getScanRepository() method retrieves the ScanRepository with the provided
// ID from the Scanner's scan_repositories map. Returns an error if unable to
// retrieve the repository with the provided ID.
func (s *Scanner) getScanRepository(id string) (*ScanRepository, error) {
	// lock the scan mutex to prevent concurrent access to the map
	s.scan_mutex.RLock()
	// unlock the scan mutex when the method returns
	defer s.scan_mutex.RUnlock()
	// retrieve the repository from the map
	repo, ok := s.scan_repositories[id]
	if !ok {
		return nil, errors.New(ErrScannerGetScanRepositoryNotFound.Error() + " repository ID =" + id)
	}
	return repo, nil
}

// processErrors() method processes errors generated by the scan.
func (s *Scanner) processErrors(
	chan_quit_in <-chan struct{},
	chan_errors_in <-chan error,
	chan_errors_out chan<- error,
) {
	s.logger.Debug().Msg("started error processor")
	defer s.logger.Debug().Msg("finished error processor")

	for {
		select {
		case <-chan_quit_in:
			s.logger.Warn().Msg("scanner error processor received quit signal")
			close(chan_errors_out)
			return
		case e := <-chan_errors_in:
			if e != nil {
				err_wrap_msg := "error running scanner"
				s.logger.Error().Err(e).Msg(err_wrap_msg)
				// handle error to determine if the scanner should continue
				// TODO
				chan_errors_out <- e
				close(chan_errors_out)
				return
			}
			return
		}
	}
}

// processRequest() method processes a single request for internal tracking
// purposes before sending the request for external processing.
func (s *Scanner) processRequest(
	r rrr.Request,
	chan_requests_out chan<- rrr.Request,
	chan_errors_out chan<- error,
) {
	// log the request
	s.logger.Trace().Msgf(
		"processing request %s : repository=%s : commit=%s : object=%s",
		r.ID,
		r.Repository.ID,
		r.Commit.ID,
		r.Object.ID,
	)
	// validate the request
	if r.ID == "" {
		chan_errors_out <- ErrProcessRequestNoID
		return
	}
	// update TrackerRequests to track the ID of the pending request
	_, err := s.TrackerRequests.Update(r.ID, tracker.KeyCodePending, "", []string{})
	if err != nil {
		chan_errors_out <- err
		return
	}
	// send the request for external processing
	chan_requests_out <- r
}

// processRequests() method processes requests for documents generated by
// the scan.
func (s *Scanner) processRequests(
	chan_quit_in <-chan struct{},
	chan_requests_in <-chan rrr.Request,
	chan_requests_out chan<- rrr.Request,
	chan_errors_out chan<- error,
) {
	s.logger.Debug().Msg("started requests processor")
	defer s.logger.Debug().Msg("finished requests processor")

	// listen for requests to process
	for {
		select {
		case <-chan_quit_in:
			return
		case r := <-chan_requests_in:
			// keep the input channel clear by processing the request in the
			// background via a separate goroutine, which sends any errors to
			// chan_errors_out
			s.processRequest(r, chan_requests_out, chan_errors_out)
		}
	}
}

// processResponse() method processes a single response to some request.
func (s *Scanner) processResponse(
	r rrr.Response,
	chan_errors_out chan<- error,
) {
	// validate the response
	if r.ID == "" {
		chan_errors_out <- ErrProcessResponseNoID
		return
	}
	// log the response
	s.logger.Trace().Msgf(
		"processing %d results for request/response ID = %s : Repository.ID : %s : Commit.ID = %s : Object.ID = %s",
		len(r.Results),
		r.ID,
		r.Repository.ID,
		r.Commit.ID,
		r.Object.ID,
	)
	// write the result(s) to the result_io store
	if len(r.Results) > 0 {
		// convert the response to a slice of rrr.ResultRecords, where
		// each rrr.ResultRecord is uniquely identified by its SHA1 hash
		result_records := rrr.ResultRecordsFromResponse(&r)
		if err := s.result_io.Write(result_records); err != nil {
			chan_errors_out <- errors.Wrap(err, ErrMsgResultWriteFailed)
		}
	}
	// update TrackerRequests to mark the associated request (ID) as complete
	s.TrackerRequests.Update(r.ID, tracker.KeyCodeComplete, "", []string{})

	scan_repo, scan_repo_err := s.getScanRepository(r.Repository.ID)
	if scan_repo_err != nil {
		chan_errors_out <- scan_repo_err
		return
	}
	// update the tracker for the associated File object to mark this
	// request/response as complete. if all requests/responses for a
	// File object are complete, the File object should be marked as
	// tracker.KeyCodeComplete.
	var file_update_code int
	var update_err error
	file_update_code, update_err = scan_repo.TrackerFiles.Update(
		r.Object.ID,
		tracker.KeyCodeComplete,
		"",
		[]string{r.ID},
	)
	if update_err != nil {
		chan_errors_out <- update_err
	}
	// only update the associated commit if file_update_code is tracker.KeyCodeComplete.
	if file_update_code == tracker.KeyCodeComplete {
		_, update_err = scan_repo.TrackerCommits.Update(
			r.Commit.ID,
			tracker.KeyCodeComplete,
			"",
			[]string{r.Object.ID},
		)
		if update_err != nil {
			chan_errors_out <- update_err
		}
	}
}

// processResponses() method processes all responses for requests generated by
// the scan.
func (s *Scanner) processResponses(
	chan_quit_in <-chan struct{},
	chan_responses_in <-chan rrr.Response,
	chan_errors_out chan<- error,
) {
	s.logger.Debug().Msg("started response processor")
	defer s.logger.Debug().Msg("finished response processor")

	// listen for responses to process
	for {
		select {
		case <-chan_quit_in:
			return
		case r := <-chan_responses_in:
			// keep the input channel clear by processing the response in the
			// background via a separate goroutine, which sends any errors to
			// chan_errors_out
			s.processResponse(r, chan_errors_out)
		}
	}
}

// reconcilePending() method reconciles pending commits and files by checking
// if all requests for a file are actually complete and if all files for a commit
// are actually complete, then updates the trackers for files and commits to
// reflect the actual state of the scan.
func (s *Scanner) reconcilePending(scan_repo *ScanRepository) {
	s.logger.Debug().Msg("started scanner reconciler")
	defer s.logger.Debug().Msg("finished scanner reconciler")

	// get the pending files for the repository
	pending_files, files_err := scan_repo.TrackerFiles.GetKeysDataForCode(tracker.KeyCodePending)
	if files_err != nil {
		s.logger.Error().Err(files_err).Msg("error getting pending files")
		return
	}
	for file_key, file_key_data := range pending_files {
		// keep track of requests that should be marked as complete in the
		// next update to the tracker for this file
		var requests_complete []string
		// iterate over the request children of the file
		for request_id, is_complete := range file_key_data.Children {
			if is_complete {
				continue
			}
			// get the tracker.KeyData for the pending request ID
			request_data, request_exists := s.TrackerRequests.Get(request_id)
			if !request_exists {
				s.logger.Error().Msgf("error getting request ID=%s", request_id)
				continue
			}
			if request_data.Code == tracker.KeyCodeComplete {
				requests_complete = append(requests_complete, request_id)
			}
		}
		if len(requests_complete) > 0 {
			// update the tracker for the file to mark the requests as complete
			_, update_err := scan_repo.TrackerFiles.Update(
				file_key,
				tracker.KeyCodeComplete,
				"",
				requests_complete,
			)
			if update_err != nil {
				s.logger.Error().Err(update_err).Msg("error updating file tracker")
			}
		}
	}

	// get the pending commits for the repository
	pending_commits, commits_err := scan_repo.TrackerCommits.GetKeysDataForCode(tracker.KeyCodePending)
	if commits_err != nil {
		s.logger.Error().Err(commits_err).Msg("error getting pending commits")
		return
	}
	for commit_key, commit_key_data := range pending_commits {
		// keep track of files that should be marked as complete in the
		// next update to the tracker for this commit
		var files_complete []string
		// iterate over the file children of the commit
		for file_key, is_complete := range commit_key_data.Children {
			if is_complete {
				continue
			}
			// get the tracker.KeyData for the pending file ID/key
			file_data, file_exists := scan_repo.TrackerFiles.Get(file_key)
			if !file_exists {
				s.logger.Error().Msgf("error getting file ID=%s", file_key)
				continue
			}
			if file_data.Code == tracker.KeyCodeComplete {
				files_complete = append(files_complete, file_key)
			}
		}
		if len(files_complete) > 0 {
			// update the tracker for the commit to mark the files as complete
			_, update_err := scan_repo.TrackerCommits.Update(
				commit_key,
				tracker.KeyCodeComplete,
				"",
				files_complete,
			)
			if update_err != nil {
				s.logger.Error().Err(update_err).Msg("error updating commit tracker")
			}
		}
	}
}

// scanRepository() method scans the repositories defined in the git config
// and sends the results to the requests channel. If an error occurs during
// the scan, the error is sent to the error channel.
func (s *Scanner) scanRepository(
	repo_url string,
	repository *git.Repository,
	errors_out chan<- error,
	done_out chan<- struct{},
) {
	s.logger.Debug().Msg("started repository scan")
	defer s.logger.Debug().Msg("finished repository scan")
	defer close(done_out)

	if errors_out == nil {
		s.logger.Panic().Msg(ErrMsgErrorChannelNil)
	}
	if repository == nil {
		errors_out <- ErrScannerRepositoryNil
	}

	// create a scan object for the repository
	scan_repo, err := NewScanRepository(NewScanRepositoryInput{
		ChannelErrors:   s.chan_errors,
		ChannelRequests: s.chan_requests,
		Config:          &s.git_config.Scan,
		Context:         s.ctx,
		Repository:      repository,
		URL:             repo_url,
	})
	if err != nil {
		errors_out <- errors.Wrap(err, ErrMsgScanRepositoryCreate)
		return
	}

	// add the ScanRepository to the map of scan repositories so that other
	// methods can access and update the state of the scan for the repository
	if add_err := s.addScanRepository(scan_repo); add_err != nil {
		errors_out <- errors.Wrap(add_err, ErrMsgAddScanRepository)
		return
	}

	// scan the repository for PHI/PII data
	if scan_err := scan_repo.Scan(s.git_manager); scan_err != nil {
		errors_out <- errors.Wrap(scan_err, ErrMsgScanRepositoryScan)
		return
	}
}

// trackScanProgress() method tracks the progress of the scan by periodically
// checking if all requests have been completed. If the scan is complete, the
// method returns. If the scan is not complete, the method continues to track
// the progress of the scan by printing the status counts for the requests.
func (s *Scanner) trackScanProgress(
	repository_id string,
	scan_done_in <-chan struct{},
	quit_out chan<- struct{},
) {
	s.logger.Debug().Msg("started scan progress tracker")
	defer s.logger.Debug().Msg("finished scan progress tracker")

	printScanCounts := func(scan_repo *ScanRepository) {
		// print the counts from scan_repo.TrackerCommits
		scan_repo.TrackerCommits.PrintCounts()
		// print the counts from scan_repo.TrackerFiles
		scan_repo.TrackerFiles.PrintCounts()
		// print the counts from TrackerRequests
		s.TrackerRequests.PrintCounts()
	}

	trackScanCounts := func() (done bool) {
		done = false
		scan_repo, err := s.getScanRepository(repository_id)
		if err != nil {
			s.logger.Error().Msgf("error getting scan repository: %s", repository_id)
			return
		}
		// print the scan counts regardless of whether the scan is complete
		printScanCounts(scan_repo)

		// check if the scan of the repository is complete, including all
		// requests/responses created from the scan of the repository
		if !scan_repo.is_scan_complete {
			s.logger.Debug().Msgf("tracking scan : scan in-progress for repository %s", scan_repo.ID)
			return
		}
		// reconcile tracker states across requests, files, and commits
		s.reconcilePending(scan_repo)
		// check if any files are still pending
		if !scan_repo.TrackerFiles.CheckAllComplete() {
			s.logger.Debug().Msgf("tracking scan : not all FILES complete for repository %s", scan_repo.ID)
			return
		}
		// check if any commits are still pending
		if !scan_repo.TrackerCommits.CheckAllComplete() {
			s.logger.Debug().Msgf("tracking scan : not all COMMITS complete for repository %s", scan_repo.ID)
			return
		}
		// check if any requests are still pending
		if !s.TrackerRequests.CheckAllComplete() {
			s.logger.Debug().Msgf("tracking scan : not all REQUESTS complete for repository %s", scan_repo.ID)
			return
		}
		s.logger.Debug().Msgf("tracking scan : cleaning up scan for repository %s", scan_repo.ID)
		// print the scan counts again before actually cleaning up
		printScanCounts(scan_repo)
		close(quit_out)
		done = true
		return
	}

	// create a ticker to periodically trigger a refresh of progress tracking
	timer := time.NewTicker(ScanRefreshInterval)

	// use scan_done var to avoid repeated processing of scan_done_in
	var scan_done bool = false

	for {
		select {
		case <-timer.C:
			// print tracker counts, then wait for the next tick
			if trackScanCounts() {
				return
			}
		case <-scan_done_in:
			if !scan_done {
				s.logger.Debug().Msg("received scan done signal")
				scan_done = true
				if trackScanCounts() {
					return
				}
			}
			continue
		}
	}
}
