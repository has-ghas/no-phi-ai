package scanner

import (
	"context"
	"sync"
	"time"

	git "github.com/go-git/go-git/v5"
	"github.com/google/uuid"
	"github.com/pkg/errors"
	"github.com/rs/zerolog"

	"github.com/has-ghas/no-phi-ai/pkg/cfg"
	nogit "github.com/has-ghas/no-phi-ai/pkg/client/no-git"
	"github.com/has-ghas/no-phi-ai/pkg/scanner/rrr"
)

// Scanner struct uses private fields to store scanner state and provides methods
// for running a scan of a git repository for PHI/PII data, recursively scanning
// the contents of files committed to each repository.
type Scanner struct {
	ID string `json:"id"`

	TrackerRequests *KeyTracker

	chan_requests     chan rrr.Request
	chan_errors       chan error
	ctx               context.Context
	git_config        *cfg.GitConfig
	git_manager       *nogit.GitManager
	logger            *zerolog.Logger
	result_io         rrr.ResultRecordIO
	scan_mutex        *sync.RWMutex
	scan_repositories map[string]*ScanRepository
}

// NewScanner() function initializes a new Scanner object.
func NewScanner(
	ctx context.Context,
	git_config *cfg.GitConfig,
	result_io rrr.ResultRecordIO,
) (*Scanner, error) {
	// ensure the context is not nil
	if ctx == nil {
		ctx = context.Background()
	}

	// create a logger from the context
	logger := zerolog.Ctx(ctx)

	// create a KeyTracker for tracking (responses to) requests
	tracker_requests, t_err := NewKeyTracker(ScanObjectTypeRequestResponse, logger)
	if t_err != nil {
		return nil, errors.Wrap(t_err, ErrMsgScannerCreate)
	}

	return &Scanner{
		ID:                uuid.NewString(),
		TrackerRequests:   tracker_requests,
		chan_requests:     make(chan rrr.Request),
		chan_errors:       make(chan error),
		ctx:               ctx,
		git_config:        git_config,
		git_manager:       nogit.NewGitManager(git_config, ctx),
		logger:            logger,
		result_io:         result_io,
		scan_mutex:        &sync.RWMutex{},
		scan_repositories: make(map[string]*ScanRepository),
	}, nil
}

// Scan() method uses channels and goroutines to coordinate the scanning of
// a git repository for PHI/PII data.
func (s *Scanner) Scan(
	chan_errors_send chan error,
	chan_request_send chan<- rrr.Request,
	chan_response_receive <-chan rrr.Response,
) {
	s.logger.Debug().Msg("started Scanner run")
	defer s.logger.Debug().Msg("finished Scanner run")

	chan_quit := make(chan struct{})
	// listen for errors generated by the scan
	go s.processErrors(chan_quit, s.chan_errors, chan_errors_send)
	// process requests for documents generated by the scan
	go s.processRequests(chan_quit, s.chan_requests, chan_request_send, s.chan_errors)
	// process responses for requests
	go s.processResponses(chan_response_receive, s.chan_errors, chan_quit)
	// start a scan for each configured repository
	for _, repo := range s.git_config.Scan.Repositories {
		// use s.git_manager to clone the repository
		repository, repository_err := s.git_manager.CloneRepo(repo)
		if repository_err != nil {
			s.chan_errors <- errors.Wrap(repository_err, ErrMsgCloneRepository)
			return
		}
		// scan the repository
		go s.scanRepository(repo, repository, s.chan_errors)
	}

	go s.trackScanProgress(chan_quit)

	// listen for quit signal
	// TODO : replace with `go s.processResults()`
	<-chan_quit
}

// addScanRepository() method adds a new ScanRepository to the Scanner's map of
// scanned repositories.
func (s *Scanner) addScanRepository(repo *ScanRepository) error {
	// ensure the repository is not nil
	if repo == nil {
		return errors.Wrap(ErrScannerAddScanRepositoryNil, ErrMsgAddScanRepository)
	}
	if repo.ID == "" {
		return errors.Wrap(ErrScannerAddScanRepositoryEmptyID, ErrMsgAddScanRepository)
	}
	s.logger.Debug().Msgf("adding scan repository for %s", repo.ID)

	// lock the scan mutex to prevent concurrent access to the map
	s.scan_mutex.Lock()
	// unlock the scan mutex when the method returns
	defer s.scan_mutex.Unlock()
	s.scan_repositories[repo.ID] = repo

	return nil
}

// getScanRepository() method retrieves the ScanRepository with the provided
// ID from the Scanner's scan_repositories map. Returns an error if unable to
// retrieve the repository with the provided ID.
func (s *Scanner) getScanRepository(id string) (*ScanRepository, error) {
	// lock the scan mutex to prevent concurrent access to the map
	s.scan_mutex.RLock()
	// unlock the scan mutex when the method returns
	defer s.scan_mutex.RUnlock()
	// retrieve the repository from the map
	repo, ok := s.scan_repositories[id]
	if !ok {
		return nil, errors.New(ErrScannerGetScanRepositoryNotFound.Error() + " repository ID =" + id)
	}
	return repo, nil
}

// processErrors() method processes errors generated by the scan.
func (s *Scanner) processErrors(
	chan_quit_in <-chan struct{},
	chan_errors_in <-chan error,
	chan_errors_out chan<- error,
) {
	s.logger.Debug().Msg("started error processor")
	defer s.logger.Debug().Msg("finished error processor")

	for {
		select {
		case <-chan_quit_in:
			close(chan_errors_out)
			return
		case e := <-chan_errors_in:
			if e != nil {
				err_wrap_msg := "error running scanner"
				s.logger.Error().Err(e).Msg(err_wrap_msg)
				// handle error to determine if the scanner should continue
				// TODO
				chan_errors_out <- e
				close(chan_errors_out)
				return
			}
			return
		}
	}
}

// processRequest() method processes a single request for internal tracking
// purposes before sending the request for external processing.
func (s *Scanner) processRequest(
	r rrr.Request,
	chan_requests_out chan<- rrr.Request,
	chan_errors_out chan<- error,
) {
	// log the request
	s.logger.Trace().Msgf(
		"processing request %s : repository=%s : commit=%s : object=%s",
		r.ID,
		r.Repository.ID,
		r.Commit.ID,
		r.Object.ID,
	)
	// validate the request
	if r.ID == "" {
		chan_errors_out <- ErrProcessRequestNoID
		return
	}
	// update TrackerRequests to track the ID of the pending request
	_, err := s.TrackerRequests.Update(r.ID, KeyCodePending, "", []string{})
	if err != nil {
		chan_errors_out <- err
		return
	}
	// send the request for external processing
	chan_requests_out <- r
}

// processRequests() method processes requests for documents generated by
// the scan.
func (s *Scanner) processRequests(
	chan_quit_in <-chan struct{},
	chan_requests_in <-chan rrr.Request,
	chan_requests_out chan<- rrr.Request,
	chan_errors_out chan<- error,
) {
	s.logger.Debug().Msg("started requests processor")
	defer s.logger.Debug().Msg("finished requests processor")

	// listen for requests to process
	for {
		select {
		case <-chan_quit_in:
			return
		case r := <-chan_requests_in:
			// keep the input channel clear by processing the request in the
			// background via a separate goroutine, which sends any errors to
			// chan_errors_out
			go s.processRequest(r, chan_requests_out, chan_errors_out)
		}
	}
}

// processResponse() method processes a single response to some request.
func (s *Scanner) processResponse(
	r rrr.Response,
	chan_errors_out chan<- error,
	chan_quit_out chan<- struct{},
) {
	printTrackerCounts := func() {
		// print the counts from TrackerRequests
		s.TrackerRequests.PrintCounts()
		for _, scan_repo := range s.scan_repositories {
			scan_repo.TrackerCommits.PrintCounts()
			scan_repo.TrackerFiles.PrintCounts()
		}
	}
	// validate the response
	if r.ID == "" {
		chan_errors_out <- ErrProcessResponseNoID
		return
	}
	// log the response
	s.logger.Trace().Msgf(
		"processing %d results for request/response ID = %s : Repository.ID : %s : Commit.ID = %s : Object.ID = %s",
		len(r.Results),
		r.ID,
		r.Repository.ID,
		r.Commit.ID,
		r.Object.ID,
	)
	// write the result(s) to the result_io store
	if len(r.Results) > 0 {
		// convert the response to a slice of rrr.ResultRecords, where
		// each rrr.ResultRecord is uniquely identified by its SHA1 hash
		result_records := rrr.ResultRecordsFromResponse(&r)
		if err := s.result_io.Write(result_records); err != nil {
			chan_errors_out <- errors.Wrap(err, ErrMsgResultWriteFailed)
		}
	}
	// update TrackerRequests to mark the associated request (ID) as complete
	s.TrackerRequests.Update(r.ID, KeyCodeComplete, "", []string{})

	scan_repo, scan_repo_err := s.getScanRepository(r.Repository.ID)
	if scan_repo_err != nil {
		chan_errors_out <- scan_repo_err
		return
	}
	// update the tracker for the associated File object to mark this
	// request/response as complete. if all requests/responses for a
	// File object are complete, the File object should be marked as
	// KeyCodeComplete.
	var file_update_code int
	file_update_code, _ = scan_repo.TrackerFiles.Update(
		r.Object.ID,
		KeyCodeComplete,
		"",
		[]string{r.ID},
	)
	// only update the associated commit if file_update_code is KeyCodeComplete.
	if file_update_code == KeyCodeComplete {
		scan_repo.TrackerCommits.Update(
			r.Commit.ID,
			KeyCodeComplete,
			"",
			[]string{r.Object.ID},
		)
		// check if the scan of the repository is complete, including all
		// requests/responses created from the scan of the repository
		if scan_repo.is_scan_complete && s.TrackerRequests.CheckAllComplete() {
			s.logger.Debug().Msgf("all requests complete for repository %s", scan_repo.ID)
			printTrackerCounts()
			// close the quit channel to stop other scanner goroutines
			close(chan_quit_out)
		}
	}
}

// processResponses() method processes all responses for requests generated by
// the scan.
func (s *Scanner) processResponses(
	chan_responses_in <-chan rrr.Response,
	chan_errors_out chan<- error,
	chan_quit chan struct{},
) {
	s.logger.Debug().Msg("started response processor")
	defer s.logger.Debug().Msg("finished response processor")

	// listen for responses to process
	for {
		select {
		case <-chan_quit:
			return
		case r := <-chan_responses_in:
			// keep the input channel clear by processing the response in the
			// background via a separate goroutine, which sends any errors to
			// chan_errors_out
			go s.processResponse(r, chan_errors_out, chan_quit)
		}
	}
}

// scanRepository() method scans the repositories defined in the git config
// and sends the results to the requests channel. If an error occurs during
// the scan, the error is sent to the error channel.
func (s *Scanner) scanRepository(repo_url string, repository *git.Repository, err_chan chan<- error) {
	s.logger.Debug().Msg("started Scanner scan")
	defer s.logger.Debug().Msg("finished Scanner scan")

	if err_chan == nil {
		s.logger.Panic().Msg(ErrMsgErrorChannelNil)
	}
	if repository == nil {
		err_chan <- ErrScannerRepositoryNil
	}

	// create a scan object for the repository
	scan_repo, err := NewScanRepository(NewScanRepositoryInput{
		ChannelErrors:   s.chan_errors,
		ChannelRequests: s.chan_requests,
		Config:          &s.git_config.Scan,
		Context:         s.ctx,
		Repository:      repository,
		URL:             repo_url,
	})
	if err != nil {
		err_chan <- errors.Wrap(err, ErrMsgScanRepositoryCreate)
		return
	}

	// add the ScanRepository to the map of scan repositories so that other
	// methods can access and update the state of the scan for the repository
	if add_err := s.addScanRepository(scan_repo); add_err != nil {
		err_chan <- errors.Wrap(add_err, ErrMsgAddScanRepository)
		return
	}

	// scan the repository for PHI/PII data
	if scan_err := scan_repo.Scan(s.git_manager); scan_err != nil {
		err_chan <- errors.Wrap(scan_err, ErrMsgScanRepositoryScan)
		return
	}
}

// trackScanProgress() method tracks the progress of the scan by periodically
// checking if all requests have been completed. If the scan is complete, the
// method returns. If the scan is not complete, the method continues to track
// the progress of the scan by printing the status counts for the requests.
func (s *Scanner) trackScanProgress(quit_chan_in <-chan struct{}) {
	s.logger.Debug().Msg("started scan progress tracker")
	defer s.logger.Debug().Msg("finished scan progress tracker")

	printTrackerCounts := func() {
		// print the counts from TrackerRequests
		s.TrackerRequests.PrintCounts()
		for _, scan_repo := range s.scan_repositories {
			scan_repo.TrackerCommits.PrintCounts()
			scan_repo.TrackerFiles.PrintCounts()
		}
	}

	// create a ticker to periodically trigger a refresh of progress tracking
	timer := time.NewTicker(ScanRefreshInterval)

	for {
		select {
		case <-timer.C:
			// print tracker counts, then wait for the next tick
			printTrackerCounts()
		case <-quit_chan_in:
			return
		}
	}
}
