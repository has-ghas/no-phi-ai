package scannerv2

import (
	"context"
	"sync"

	git "github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing/object"
	"github.com/pkg/errors"
	"github.com/rs/zerolog"

	"github.com/has-ghas/no-phi-ai/pkg/cfg"
	nogit "github.com/has-ghas/no-phi-ai/pkg/client/no-git"
	"github.com/has-ghas/no-phi-ai/pkg/scannerv2/rrr"
)

// ScanRepository struct embeds the ScanObject struct and adds fields
// and methods specific to scanning a git.Repository.
type ScanRepository struct {
	// ID should be the (escaped) URL of the repository.
	ID string `json:"id"`
	// Name is the friendly name of the object, such as the name
	// of the file, organization, repository, etc.
	Name string `json:"name"`
	// The unique URL associated with the object.
	URL string `json:"url"`

	TrackerCommits *KeyTracker
	TrackerFiles   *KeyTracker

	channel_commits  chan *object.Commit
	channel_errors   chan<- error
	channel_files    chan *object.File
	channel_requests chan<- rrr.Request
	config           *cfg.GitScanConfig
	ctx              context.Context
	logger           *zerolog.Logger
	repository       *git.Repository
}

// NewScanRepositoryInput struct type is used to pass input parameters to the
// NewScanRepository() function.
type NewScanRepositoryInput struct {
	ChannelErrors   chan<- error
	ChannelRequests chan<- rrr.Request
	Config          *cfg.GitScanConfig
	Context         context.Context
	Repository      *git.Repository
	URL             string
}

// NewScanRepository() function initializes a new ScanRepository object.
func NewScanRepository(in NewScanRepositoryInput) (*ScanRepository, error) {
	if in.Context == nil {
		return nil, errors.Wrap(ErrScanRepositoryContextNil, ErrMsgScanRepositoryCreate)
	}
	if in.Config == nil {
		return nil, errors.Wrap(ErrScanRepositoryConfigNil, ErrMsgScanRepositoryCreate)
	}
	if in.ChannelRequests == nil {
		return nil, errors.Wrap(ErrScanRepositoryChannelRequestsNil, ErrMsgScanRepositoryCreate)
	}
	if in.ChannelErrors == nil {
		return nil, errors.Wrap(ErrScanRepositoryChannelErrorsNil, ErrMsgScanRepositoryCreate)
	}
	if in.Repository == nil {
		return nil, errors.Wrap(ErrScanRepositoryRepositoryNil, ErrMsgScanRepositoryCreate)
	}

	name, err := nogit.ParseRepoNameFromURL(in.URL)
	if err != nil {
		return nil, errors.Wrap(err, ErrMsgScanRepositoryCreate)
	}

	logger := zerolog.Ctx(in.Context)

	// create a new KeyTracker for tracking scanned commits
	tracker_commits, t_err := NewKeyTracker(ScanObjectTypeCommit, logger)
	if t_err != nil {
		return nil, errors.Wrap(t_err, ErrMsgScanRepositoryCreate)
	}
	// create a new KeyTracker for tracking scanned files
	tracker_files, t_err := NewKeyTracker(ScanObjectTypeFile, logger)
	if t_err != nil {
		return nil, errors.Wrap(t_err, ErrMsgScanRepositoryCreate)
	}

	return &ScanRepository{
		ID:               in.URL,
		Name:             name,
		URL:              in.URL,
		channel_commits:  make(chan *object.Commit),
		channel_errors:   in.ChannelErrors,
		channel_files:    make(chan *object.File),
		channel_requests: in.ChannelRequests,
		ctx:              in.Context,
		config:           in.Config,
		logger:           logger,
		repository:       in.Repository,
		TrackerCommits:   tracker_commits,
		TrackerFiles:     tracker_files,
	}, nil
}

// GetRepository() method returns a pointer to the git.Repository
// associated with the ScanRepository.
func (sr *ScanRepository) GetRepository() *git.Repository {
	return sr.repository
}

// Scan() method runs the scan of the repository and keeps track of the
// progress of the scan by updating private fields of the ScanRepository.
func (sr *ScanRepository) Scan(gm *nogit.GitManager) (e error) {
	if sr.repository == nil {
		return errors.Wrap(ErrScanRepositoryRepositoryNil, ErrMsgScanRepositoryScan)
	}

	sr.logger.Debug().Msgf("started scan of repository %s", sr.URL)
	defer sr.logger.Debug().Msgf("finished scan of repository %s", sr.URL)

	// get an iterator for the commits in the repository
	var commit_iterator object.CommitIter
	commit_iterator, e = sr.repository.CommitObjects()
	if e != nil {
		if commit_iterator != nil {
			commit_iterator.Close()
		}
		return
	}
	defer commit_iterator.Close()

	wg := &sync.WaitGroup{}
	// start a goroutine to process commits generated by the iterator
	wg.Add(1)
	go sr.processCommits(wg)

	// iterate through the commits in the repository history
	e = commit_iterator.ForEach(sr.scanCommit)
	if e != nil {
		e = errors.Wrapf(e, "failed to iterate through commits in repository %s", sr.URL)
		// return any error encountered while iterating through the commits
		return
	}
	// close the channel for commits to signal the processCommits goroutine
	// to finish
	close(sr.channel_commits)
	// wait for the processCommits goroutine to finish
	wg.Wait()

	// print the counts of the scanned commits and files
	sr.TrackerCommits.PrintCounts()
	sr.TrackerFiles.PrintCounts()

	return
}

func (sr *ScanRepository) processCommits(wg_main *sync.WaitGroup) {
	defer wg_main.Done()

	wg_loop := &sync.WaitGroup{}
	processCommit := func(commit *object.Commit) {
		defer wg_loop.Done()

		update_code, init_err := sr.TrackerCommits.Update(
			commit.Hash.String(),
			KeyCodeInit,
			"",
			[]string{},
		)
		if init_err != nil {
			sr.channel_errors <- errors.Wrapf(init_err, ErrMsgTrackerUpdateCommit, commit.Hash.String())
			return
		}

		// skip commits that have already been scanned
		if update_code > KeyCodeInit {
			sr.logger.Trace().Msgf(
				"repository %s : skipping previously scanned commit %s",
				sr.URL,
				commit.Hash.String(),
			)
			return
		}

		sr.logger.Debug().Msgf(
			"repository %s : scanning commit %s",
			sr.URL,
			commit.Hash.String(),
		)

		// get the tree of objects associated with the commit
		tree, err := commit.Tree()
		if err != nil {
			_, err = sr.TrackerCommits.Update(
				commit.Hash.String(),
				KeyCodeError,
				err.Error(),
				[]string{},
			)
			if err != nil {
				err = errors.Wrapf(err, ErrMsgTrackerUpdateCommit, commit.Hash.String())
				sr.channel_errors <- err
				return
			}
		}

		// iterate through the files in the commit tree
		err = tree.Files().ForEach(sr.scanFile(commit))
		if err != nil {
			err = errors.Wrapf(err, ErrMsgTrackerUpdateCommit, commit.Hash.String())
			sr.TrackerCommits.Update(
				commit.Hash.String(),
				KeyCodeError,
				err.Error(),
				[]string{},
			)
			sr.channel_errors <- err
			return
		}

		// attempt to update the commit code to "complete" status, but ignore any error
		// and accept that the commit may be left in "pending" status if the key has
		// children that are still in an incomplete (bool=false) state
		sr.TrackerCommits.Update(
			commit.Hash.String(),
			KeyCodeComplete,
			"",
			[]string{},
		)
	}
	for commit := range sr.channel_commits {
		wg_loop.Add(1)
		go processCommit(commit)
	}
	wg_loop.Wait()
}

// scanCommit() method scans the tree of the object.Commit for files
// containing any PHI/PII entities.
func (sr *ScanRepository) scanCommit(commit *object.Commit) error {
	// send the commit to the channel for processing
	sr.channel_commits <- commit
	return nil
}

// scanFile() method returns an anonymous function that can be used to iterate through
// the files in the associated commit tree and scan each file for PHI/PII entities.
func (sr *ScanRepository) scanFile(commit *object.Commit) func(*object.File) error {
	return func(file *object.File) error {
		code, err := sr.TrackerFiles.Update(
			file.Hash.String(),
			KeyCodeInit,
			"",
			[]string{},
		)
		if err != nil {
			return errors.Wrapf(err, ErrMsgScanTrackerUpdateFile, file.Hash.String())
		}
		// skip files that have already been scanned
		if code > KeyCodeInit {
			sr.logger.Trace().Msgf(
				"commit %s : skipping previously scanned file %s : code=%d",
				commit.Hash.String(),
				file.Hash.String(),
				code,
			)
			return nil
		}

		// check if the file should be ignored instead of scanned
		should_ignore, ignore_reason := IgnoreFileObject(
			file,
			sr.config.Extensions,
			sr.config.IgnoreExtensions,
		)
		if should_ignore {
			sr.logger.Trace().Msgf(
				"commit %s : skipping scan of file %s : %s",
				commit.Hash.String(),
				file.Hash.String(),
				ignore_reason,
			)
			_, err = sr.TrackerFiles.Update(
				file.Hash.String(),
				KeyCodeIgnore,
				ignore_reason,
				[]string{},
			)
			return err
		}
		if ignore_reason != "" {
			sr.logger.Warn().Msgf(
				"commit %s : file %s : ignore reason => %s",
				commit.Hash.String(),
				file.Hash.String(),
				ignore_reason,
			)
		}
		// update tracker for the associated commit to indicate "pending" status
		_, err = sr.TrackerCommits.Update(
			commit.Hash.String(),
			KeyCodePending,
			"",
			[]string{file.Hash.String()},
		)
		if err != nil {
			return errors.Wrapf(err, ErrMsgTrackerUpdateCommit, commit.Hash.String())
		}

		sr.logger.Debug().Msgf(
			"commit %s : scanning file %s : %s",
			commit.Hash.String(),
			file.Hash.String(),
			file.Name,
		)
		// generate and send requests for the contents of the file
		requests, r_err := rrr.ChunkFileToRequests(rrr.ChunkFileInput{
			CommitID:     commit.Hash.String(),
			File:         file,
			MaxChunkSize: sr.config.Limits.MaxRequestChunkSize,
			RepoID:       sr.ID,
		})
		if r_err != nil {
			sr.logger.Error().Err(r_err).Msgf("commit %s : failed to generate requests for file %s", commit.Hash.String(), file.Hash.String())
			sr.TrackerFiles.Update(
				file.Hash.String(),
				KeyCodeError,
				r_err.Error(),
				[]string{},
			)
			return r_err
		}
		if len(requests) == 0 {
			if file.Size > 0 {
				sr.logger.Warn().Msgf(
					"commit %s : no requests generated for file ID=%s : Name=%s : size=%d",
					commit.Hash.String(),
					file.Hash.String(),
					file.Name,
					file.Size,
				)
			}
			// no requests were generated for the file, so nothing is pending
			// and there is no need to update the tracker
			return nil
		}
		var child_keys []string
		// send each request to the channel for processing
		for _, req := range requests {
			child_keys = append(child_keys, req.ID)
			sr.channel_requests <- req
		}
		// update tracker to mark the scan of this file as "pending"
		_, err = sr.TrackerFiles.Update(
			file.Hash.String(),
			KeyCodePending,
			"",
			child_keys,
		)
		if err != nil {
			return errors.Wrapf(err, ErrMsgScanTrackerUpdateFile, file.Hash.String())
		}

		return nil
	}
}
