package scannerv2

import (
	"context"
	"sync"

	"github.com/google/uuid"
	"github.com/pkg/errors"
	"github.com/rs/zerolog"

	"github.com/has-ghas/no-phi-ai/pkg/cfg"
	"github.com/has-ghas/no-phi-ai/pkg/client/az"
	nogit "github.com/has-ghas/no-phi-ai/pkg/client/no-git"
)

// Scanner struct uses private fields to store scanner state and provides methods
// for running a scan of a git repository for PHI/PII data, recursively scanning
// the contents of files committed to each repository.
type Scanner struct {
	ID string `json:"id"`

	ai                *az.EntityDetectionAI
	chan_requests     chan Request
	chan_responses    chan Response
	chan_errors       chan error
	ctx               context.Context
	git_config        *cfg.GitConfig
	git_manager       *nogit.GitManager
	logger            *zerolog.Logger
	scan_mutex        *sync.RWMutex
	scan_repositories map[string]*ScanRepository
}

// NewScanner() function initializes a new Scanner object.
func NewScanner(ctx context.Context, config *cfg.Config) (*Scanner, error) {
	// ensure the context is not nil
	if ctx == nil {
		ctx = context.Background()
	}

	ai, ai_err := az.NewEntityDetectionAI(config)
	if ai_err != nil {
		return nil, ai_err
	}

	// create a logger from the context
	logger := zerolog.Ctx(ctx)

	return &Scanner{
		ID:                uuid.NewString(),
		ai:                ai,
		chan_requests:     make(chan Request),
		chan_responses:    make(chan Response),
		chan_errors:       make(chan error),
		ctx:               ctx,
		git_config:        &config.Git,
		git_manager:       nogit.NewGitManager(&config.Git, ctx, logger),
		logger:            logger,
		scan_mutex:        &sync.RWMutex{},
		scan_repositories: make(map[string]*ScanRepository),
	}, nil
}

// Run() method uses channels and goroutines to coordinate the scanning of git
// repositories for PHI/PII data.
func (s *Scanner) Run(chan_quit chan error) {
	s.logger.Debug().Msg("started Scanner run")
	defer s.logger.Debug().Msg("finished Scanner run")

	// listen for errors generated by the scan
	go s.processErrors(s.chan_errors, chan_quit)
	// process requests for documents generated by the scan
	go s.processRequests(s.chan_requests, s.chan_errors)
	// process responses for document requests
	go s.processResponses(s.chan_responses, s.chan_errors)
	// start the scan
	go s.scan(s.chan_errors)

	// listen for quit signal
	<-chan_quit
}

// addScanRepository() method adds a new ScanRepository to the Scanner's map of
// scanned repositories.
func (s *Scanner) addScanRepository(repo *ScanRepository) error {
	// ensure the repository is not nil
	if repo == nil {
		return errors.Wrap(ErrScannerAddScanRepositoryNil, ErrMsgAddScanRepository)
	}
	if repo.ID == "" {
		return errors.Wrap(ErrScannerAddScanRepositoryEmptyID, ErrMsgAddScanRepository)
	}
	s.logger.Debug().Msgf("adding scan repository for %s", repo.ID)

	// lock the scan mutex to prevent concurrent access to the map
	s.scan_mutex.Lock()
	// unlock the scan mutex when the method returns
	defer s.scan_mutex.Unlock()
	s.scan_repositories[repo.ID] = repo

	return nil
}

// processRequests() method processes requests for documents generated by
// the scan.
func (s *Scanner) processRequests(chan_requests_in <-chan Request, chan_errors_out chan<- error) {
	s.logger.Debug().Msg("started document request processor")
	defer s.logger.Debug().Msg("finished document request processor")

	// listen for document requests to process
	for {
		select {
		case <-s.ctx.Done():
			return
		case r := <-chan_requests_in:
			if r.ID == "" {
				chan_errors_out <- ErrProcessRequestNoID
				continue
			}
			s.logger.Trace().Msgf("processing document request for ID = %s", r.ID)
			// process the document from the request wrapper
			// TODO
			continue
		}
	}
}

// processResponses() method processes responses for document requests
// generated by the scan.
func (s *Scanner) processResponses(chan_responses_in <-chan Response, chan_errors_out chan<- error) {
	s.logger.Debug().Msg("started document response processor")
	defer s.logger.Debug().Msg("finished document response processor")

	// listen for document responses to process
	for {
		select {
		case <-s.ctx.Done():
			return
		case r := <-chan_responses_in:
			if r.ID == "" {
				chan_errors_out <- ErrProcessResponseNoID
				continue
			}
			s.logger.Trace().Msgf("processing document response for ID = %s", r.ID)
			// process the document response from the response wrapper
			// TODO
			continue
		}
	}
}

// processErrors() method processes errors generated by the scan.
func (s *Scanner) processErrors(chan_errors_in <-chan error, chan_quit_out chan<- error) {
	s.logger.Debug().Msg("started error processor")
	defer s.logger.Debug().Msg("finished error processor")

	for {
		select {
		case <-s.ctx.Done():
			s.logger.Debug().Msg("scanner context done")
			// send a nil error to the quit channel to indicate that the
			// scanner has completed
			close(chan_quit_out)
			return
		case e := <-chan_errors_in:
			if e != nil {
				err_wrap_msg := "error running scanner"
				s.logger.Error().Err(e).Msg(err_wrap_msg)
				chan_quit_out <- errors.Wrap(e, err_wrap_msg)
				close(chan_quit_out)
				return
			}
			s.logger.Info().Msg("error processor received nil error")
			// handle error to determine if the scanner should continue
			// TODO
			close(chan_quit_out)
			return
		}
	}
}

// scan() method scans the repositories defined in the git configuration
// and sends the results to the document request channel. If an error
// occurs during the scan, the error is sent to the error channel.
func (s *Scanner) scan(err_chan chan<- error) {
	s.logger.Debug().Msg("started Scanner scan")
	defer s.logger.Debug().Msg("finished Scanner scan")

	if err_chan == nil {
		s.logger.Panic().Msg("received nil error channel as input")
	}

	for _, repo := range s.git_config.Scan.Repositories {
		// create a scan object for the repository
		scan_repo, err := NewScanRepository(s.ctx, repo, &s.git_config.Scan, s.chan_requests)
		if err != nil {
			err_chan <- errors.Wrap(err, "failed to create scan repository object")
			return
		}

		// add the ScanRepository to the map of scan repositories so that other
		// methods can access and update the state of the scan for the repository
		if add_err := s.addScanRepository(scan_repo); add_err != nil {
			err_chan <- errors.Wrap(add_err, "failed to add scan repository")
			return
		}

		// scan the repository for PHI/PII data
		if scan_err := scan_repo.Scan(s.git_manager); scan_err != nil {
			err_chan <- errors.Wrap(scan_err, "failed to scan repository")
			return
		}
	}

	// send a nil error to the err_chan to indicate that the scan has completed
	err_chan <- nil
}
