package scannerv2

import (
	"context"
	"sync"

	"github.com/google/uuid"
	"github.com/pkg/errors"
	"github.com/rs/zerolog"

	"github.com/has-ghas/no-phi-ai/pkg/cfg"
	"github.com/has-ghas/no-phi-ai/pkg/client/az"
	nogit "github.com/has-ghas/no-phi-ai/pkg/client/no-git"
)

// Scanner struct uses private fields to store scanner state and provides methods
// for running a scan of a git repository for PHI/PII data, recursively scanning
// the contents of files committed to each repository.
type Scanner struct {
	ID string `json:"id"`

	TrackerRequests *KeyTracker

	ai                *az.EntityDetectionAI
	chan_requests     chan Request
	chan_errors       chan error
	ctx               context.Context
	git_config        *cfg.GitConfig
	git_manager       *nogit.GitManager
	logger            *zerolog.Logger
	result_io         ResultRecordIO
	scan_mutex        *sync.RWMutex
	scan_repositories map[string]*ScanRepository
}

// NewScanner() function initializes a new Scanner object.
func NewScanner(ctx context.Context, config *cfg.Config, result_io ResultRecordIO) (*Scanner, error) {
	// ensure the context is not nil
	if ctx == nil {
		ctx = context.Background()
	}

	ai, ai_err := az.NewEntityDetectionAI(config)
	if ai_err != nil {
		return nil, ai_err
	}

	// create a logger from the context
	logger := zerolog.Ctx(ctx)

	// create a KeyTracker for tracking (responses to) requests
	tracker_requests, t_err := NewKeyTracker(ScanObjectTypeRequestResponse, logger)
	if t_err != nil {
		return nil, errors.Wrap(t_err, ErrMsgScannerCreate)
	}

	return &Scanner{
		ID:                uuid.NewString(),
		TrackerRequests:   tracker_requests,
		ai:                ai,
		chan_requests:     make(chan Request),
		chan_errors:       make(chan error),
		ctx:               ctx,
		git_config:        &config.Git,
		git_manager:       nogit.NewGitManager(&config.Git, ctx, logger),
		logger:            logger,
		result_io:         result_io,
		scan_mutex:        &sync.RWMutex{},
		scan_repositories: make(map[string]*ScanRepository),
	}, nil
}

// Run() method uses channels and goroutines to coordinate the scanning of git
// repositories for PHI/PII data.
func (s *Scanner) Run(
	chan_quit chan error,
	chan_request_send chan<- Request,
	chan_response_receive <-chan Response,
) {
	s.logger.Debug().Msg("started Scanner run")
	defer s.logger.Debug().Msg("finished Scanner run")

	// listen for errors generated by the scan
	go s.processErrors(s.chan_errors, chan_quit)
	// process requests for documents generated by the scan
	go s.processRequests(s.chan_requests, chan_request_send, s.chan_errors)
	// process responses for requests
	go s.processResponses(chan_response_receive, s.chan_errors)
	// start the scan
	go s.scan(s.chan_errors)

	// listen for quit signal
	<-chan_quit
}

// addScanRepository() method adds a new ScanRepository to the Scanner's map of
// scanned repositories.
func (s *Scanner) addScanRepository(repo *ScanRepository) error {
	// ensure the repository is not nil
	if repo == nil {
		return errors.Wrap(ErrScannerAddScanRepositoryNil, ErrMsgAddScanRepository)
	}
	if repo.ID == "" {
		return errors.Wrap(ErrScannerAddScanRepositoryEmptyID, ErrMsgAddScanRepository)
	}
	s.logger.Debug().Msgf("adding scan repository for %s", repo.ID)

	// lock the scan mutex to prevent concurrent access to the map
	s.scan_mutex.Lock()
	// unlock the scan mutex when the method returns
	defer s.scan_mutex.Unlock()
	s.scan_repositories[repo.ID] = repo

	return nil
}

// getScanRepository() method retrieves the ScanRepository with the provided
// ID from the Scanner's scan_repositories map. Returns an error if unable to
// retrieve the repository with the provided ID.
func (s *Scanner) getScanRepository(id string) (*ScanRepository, error) {
	// lock the scan mutex to prevent concurrent access to the map
	s.scan_mutex.RLock()
	// unlock the scan mutex when the method returns
	defer s.scan_mutex.RUnlock()
	// retrieve the repository from the map
	repo, ok := s.scan_repositories[id]
	if !ok {
		return nil, errors.Wrapf(ErrScannerGetScanRepositoryNotFound, "repository ID = %s", id)
	}
	return repo, nil
}

func (s *Scanner) processRequest(
	r Request,
	chan_requests_out chan<- Request,
	chan_errors_out chan<- error,
) {
	// log the request
	s.logger.Trace().Msgf(
		"processing request %s : repository=%s : commit=%s : object=%s",
		r.ID,
		r.Repository.ID,
		r.Commit.ID,
		r.Object.ID,
	)
	// validate the request
	if r.ID == "" {
		chan_errors_out <- ErrProcessRequestNoID
		return
	}
	// update TrackerRequests to track the ID of the pending request
	_, err := s.TrackerRequests.Update(r.ID, KeyCodePending, "", []string{})
	if err != nil {
		chan_errors_out <- err
		return
	}
	// send the request for external processing
	chan_requests_out <- r
}

// processRequests() method processes requests for documents generated by
// the scan.
func (s *Scanner) processRequests(
	chan_requests_in <-chan Request,
	chan_requests_out chan<- Request,
	chan_errors_out chan<- error,
) {
	s.logger.Debug().Msg("started requests processor")
	defer s.logger.Debug().Msg("finished requests processor")

	// listen for requests to process
	for {
		select {
		case <-s.ctx.Done():
			return
		case r := <-chan_requests_in:
			// keep the input channel clear by processing the request in the
			// background via a separate goroutine, which sends any errors to
			// chan_errors_out
			go s.processRequest(r, chan_requests_out, chan_errors_out)
		}
	}
}

// processResponse() method processes a single response to some request.
func (s *Scanner) processResponse(r Response, chan_errors_out chan<- error) {
	// validate the response
	if r.ID == "" {
		chan_errors_out <- ErrProcessResponseNoID
		return
	}
	// log the response
	s.logger.Trace().Msgf(
		"processing %d results for request/response ID = %s : Repository.ID : %s : Commit.ID = %s : Object.ID = %s",
		len(r.Results),
		r.ID,
		r.Repository.ID,
		r.Commit.ID,
		r.Object.ID,
	)
	// write the result(s) to the result_io store
	if len(r.Results) > 0 {
		// convert the response to a slice of ResultRecords, where
		// each ResultRecord is uniquely identified by its SHA1 hash
		result_records := ResultRecordsFromResponse(&r)
		if err := s.result_io.Write(result_records); err != nil {
			chan_errors_out <- errors.Wrap(err, ErrMsgResultWriteFailed)
		}
	}
	// update TrackerRequests to mark the associated request (ID) as complete
	_, err := s.TrackerRequests.Update(r.ID, KeyCodeComplete, "", []string{})
	if err != nil {
		chan_errors_out <- err
		return
	}
	scan_repo, scan_repo_err := s.getScanRepository(r.Repository.ID)
	if scan_repo_err != nil {
		chan_errors_out <- scan_repo_err
		return
	}
	// update the tracker for the associated File object to mark this
	// request/response as complete. if all requests/responses for a
	// File object are complete, the File object should be marked as
	// KeyCodeComplete.
	var file_update_code int
	file_update_code, err = scan_repo.TrackerFiles.Update(
		r.Object.ID,
		KeyCodeComplete,
		"",
		[]string{r.ID},
	)
	if err != nil {
		chan_errors_out <- err
		return
	}
	// only update the associated commit if the file update code is
	// KeyCodeComplete.
	if file_update_code == KeyCodeComplete {
		_, err = scan_repo.TrackerCommits.Update(
			r.Commit.ID,
			KeyCodeComplete,
			"",
			[]string{r.Object.ID},
		)
		if err != nil {
			chan_errors_out <- err
			return
		}
	}
}

// processResponses() method processes all responses for requests generated by
// the scan.
func (s *Scanner) processResponses(
	chan_responses_in <-chan Response,
	chan_errors_out chan<- error,
) {
	s.logger.Debug().Msg("started response processor")
	defer s.logger.Debug().Msg("finished response processor")

	// listen for responses to process
	for {
		select {
		case <-s.ctx.Done():
			return
		case r := <-chan_responses_in:
			// keep the input channel clear by processing the response in the
			// background via a separate goroutine, which sends any errors to
			// chan_errors_out
			go s.processResponse(r, chan_errors_out)
		}
	}
}

// processErrors() method processes errors generated by the scan.
func (s *Scanner) processErrors(chan_errors_in <-chan error, chan_quit_out chan<- error) {
	s.logger.Debug().Msg("started error processor")
	defer s.logger.Debug().Msg("finished error processor")

	for {
		select {
		case <-s.ctx.Done():
			s.logger.Debug().Msg("scanner context done")
			// send a nil error to the quit channel to indicate that the
			// scanner has completed
			close(chan_quit_out)
			return
		case e := <-chan_errors_in:
			if e != nil {
				err_wrap_msg := "error running scanner"
				s.logger.Error().Err(e).Msg(err_wrap_msg)
				chan_quit_out <- errors.Wrap(e, err_wrap_msg)
				close(chan_quit_out)
				return
			}
			s.logger.Info().Msg("error processor received nil error")
			// handle error to determine if the scanner should continue
			// TODO
			close(chan_quit_out)
			return
		}
	}
}

// scan() method scans the repositories defined in the git configuration and
// sends the results to the requests channel. If an error occurs during the
// scan, the error is sent to the error channel.
func (s *Scanner) scan(err_chan chan<- error) {
	s.logger.Debug().Msg("started Scanner scan")
	defer s.logger.Debug().Msg("finished Scanner scan")

	if err_chan == nil {
		s.logger.Panic().Msg("received nil error channel as input")
	}

	// scan the configured list of repositories
	for _, repo := range s.git_config.Scan.Repositories {
		// create a scan object for the repository
		scan_repo, err := NewScanRepository(s.ctx, repo, &s.git_config.Scan, s.chan_requests)
		if err != nil {
			err_chan <- errors.Wrap(err, "failed to create scan repository object")
			return
		}

		// add the ScanRepository to the map of scan repositories so that other
		// methods can access and update the state of the scan for the repository
		if add_err := s.addScanRepository(scan_repo); add_err != nil {
			err_chan <- errors.Wrap(add_err, "failed to add scan repository")
			return
		}

		// scan the repository for PHI/PII data
		if scan_err := scan_repo.Scan(s.git_manager); scan_err != nil {
			err_chan <- errors.Wrap(scan_err, "failed to scan repository")
			return
		}
	}

	// print the counts from TrackerRequests
	s.TrackerRequests.PrintCounts()

	// send a nil error to the err_chan to indicate that the scan has completed
	err_chan <- nil
}
