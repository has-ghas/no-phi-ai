package scannerv2

import (
	"crypto/sha1"
	"encoding/hex"
	"strconv"
	"strings"
)

// Result struct contains the detection results from a single service in
// response to a request to process a portion of the source object/text.
type Result struct {
	// Category is the result type
	Category string `json:"category"`
	// ConfidenceScore is specific to the extracted result and
	// is a value between 0 and 1, where 0.99 represents extreme
	// confidence that PHI/PII data was detected.
	ConfidenceScore float64 `json:"confidenceScore"`
	// Length is the number of characters in the result text.
	Length int `json:"length"`
	// Offset is the start position of the result text within the source
	// text, which may have its own offset.
	Offset int `json:"offset"`
	// Service is the location (e.g. URL) of the service that processed
	// the request and returned the result.
	Service string `json:"service"`
	// Subcategory is the (optional) result sub-type.
	Subcategory string `json:"subcategory"`
	// Text is the result text as it appears in the document
	Text string `json:"text"`
}

// Hash() method returns a unique identifier for the result, which is a
// SHA1 hash of the input ID strings and the stringified result data.
func (r Result) Hash(repo_id, commit_id, object_id string) string {
	// hash the result generated by the String() method
	sum := sha1.Sum([]byte(r.String(repo_id, commit_id, object_id)))
	// return the hex-encoded hash
	return hex.EncodeToString(sum[:])
}

// String() method returns a string representation of the result, which
// is a joined string of the input IDs and the stringified result data.
func (r Result) String(repo_id, commit_id, object_id string) string {
	elements := []string{
		noEmpty(repo_id),
		noEmpty(commit_id),
		noEmpty(object_id),
		noEmpty(r.Category),
		noEmpty(strconv.FormatFloat(r.ConfidenceScore, 'f', -1, 64)),
		noEmpty(strconv.Itoa(r.Length)),
		noEmpty(strconv.Itoa(r.Offset)),
		noEmpty(r.Service),
		noEmpty(r.Subcategory),
		noEmpty(r.Text),
	}
	// join the elements into a single string
	return strings.Join(elements, ResultSeparatorUID)
}

// ResultRecord struct embeds structs containing all fields required to
// store a result record in the database, including metadata from the
// request/response and the result itself.
type ResultRecord struct {
	// Hash is the unique identifier of the result record, which is a
	// sha1 hash of the associated IDs and stringified result data.
	Hash string `json:"hash"`
	// embed the MetadataRequestResponse struct
	MetadataRequestResponse
	// embed the Result struct
	Result
}

// ResultRecordIO interface defines the methods for reading and writing
// detection result records from/to some store (e.g. memory, file,
// database).
type ResultRecordIO interface {
	Delete(id string) error
	List() ([]ResultRecord, error)
	Read(id string) (ResultRecord, error)
	Write(results []ResultRecord) error
}

// ResultRecordsFromResponse() function converts a Response object into a
// slice of ResultRecord objects, where each ResultRecord contains the
// metadata from the response and a single result from the response.
func ResultRecordsFromResponse(resp *Response) []ResultRecord {
	records := make([]ResultRecord, 0)
	for _, result := range resp.Results {
		records = append(records, ResultRecord{
			// create a unique (hash) identifier for the result record
			Hash:                    result.Hash(resp.Repository.ID, resp.Commit.ID, resp.Object.ID),
			MetadataRequestResponse: resp.MetadataRequestResponse,
			Result:                  result,
		})
	}
	return records
}

func noEmpty(s string) string {
	if s == "" {
		return ResultReplaceEmptyElement
	}
	return s
}
